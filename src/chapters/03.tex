\chapter{Chosen technologies}
\label{chapter:chosentechnologies}

This chapter introduces the main technologies, which I built Diplomatiq on.

\section{Spring Boot}

I wanted to build Diplomatiq's back end application on a solid, production-grade solution. I also wanted to collect relevant experience in Spring\footnote{https://spring.io}, mainly in Spring Boot\footnote{https://spring.io/projects/spring-boot} development for professional purposes. Spring Boot offers that it makes it easy to create stand-alone, production-grade Spring based Applications that one can \textquote{just run}~\cite{spring-boot-reference-docs}. As it is a mature, production-grade framework, it satisfies the first aspect, thus I decided that I implement Diplomatiq's back end application with the Spring Boot framework.

\section{Angular}

I wanted to implement Diplomatiq's client application as a single-page web application, offering progressive, native-like experience to users, which is ubiquitously available with the help of only a web browser. Since the envisioned application satisfying all requirements of the Model United Nations framework would be huge in terms of code and components, a scalable, mature solution is needed, which makes use of cutting-edge web technologies, such as lazy loading application modules. Angular\footnote{https://angular.io} is a scalable, well-maintained, complete framework, and also my primary choice for larger web application projects.

I have been developing smaller and larger Angular applications in my professional capacity for the last three years. I trust my experience, but I want to learn new aspects too, thus I hope that Diplomatiq will become one of the largest projects I ever worked on.

\section{Neo4j}

Graphs are mathematically defined data structures being broadly used in several fields of computer science. Recent technologies and implementations made possible for developers to easily embed graph data models into their applications. There are numerous real-world scenarios which can be represented more efficiently as graphs (\emph{nodes} connected to each other by \emph{edges}), than with the traditional, relational approach.

Graph databases are NoSQL databases, which store data in graphs instead of the traditional, table-based approach.\footnote{The underlying data storage methods vary. There are graph databases which store graph data in relational tables, introducing another layer of abstraction between the stored physical data and the database.} In graph databases, a relationship represented as an edge in the graph is a \textquote{first-class} entity, and has the same basic storage characteristics as a node. Relationships are directly linked to entities, and therefore entities are directly linked to each other via relationships. This allows the querying of related entities to be fast, since the process does not involve lookups.

\subsection{The property graph data model}

It is common to define graphs as a set of objects, in which some object pairs are connected to each other. In this model, an object is called \emph{vertex} or \emph{node} or \emph{point}, and a connection between two \emph{vertices} is called \emph{edge} or \emph{relation}. Connections can be detailed further by specifying their directionality, also they can be \emph{labeled} to define them even more. Similarly labeling vertices leads to the model of \emph{typed graphs}. If we assign properties to the nodes or relations, we get the model of \emph{property graphs}. Properties, as shown in \Cref{fig:property-graph}, are usually key-value pairs in the format of \lstinline{key = `value'}. Generally, keys are strings, and values represent common data types like string, integer, float, etc.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth, trim=12mm 12mm 12mm 12mm,clip]{figures/property-graph.pdf}
    \caption{Two persons' relationship modeled with a property graph}
    \label{fig:property-graph}
\end{figure}

\subsection{Neo4j}
\label{subsection:preliminaryneo4j}

Among a handful of graph database vendors~\cite{graph-dbs}, Neo Technology's Neo4j is the most popular one~\cite{graph-dbs-raking}. It features full ACID-compliance upon a pure graph data model, contrary to other vendors' multi-model approaches. Besides Neo Technology, Neo4j is backed by the open-source community as well~\cite{neo4j-github}. There are two variants: \emph{Community Edition} and \emph{Enterprise Edition} with an extended feature set~\cite{neo4j-licensing}. Neo4j also offers a program tailored to startup companies~\cite{neo4j-startup-program}. With the help of this startup program, companies can build their applications on the Enterprise Edition of the Neo4j platform, free of charge.\footnote{Certain limitations apply: the company must have at most 50 employees and at most \$3 million annual revenue, among others~\cite{neo4j-startup-program}.}

\subsection{Cypher}

Cypher is a query language developed especially for graph databases by Neo Technology~\cite{neo4j-cypher}. \Cref{fig:cypher-intro} shows that the language uses a sort of ASCII-art to represent nodes and relationships: nodes are in parentheses, relationships are in brackets surrounded by relationship direction information.

\begin{figure}[!htb]
    \centering
    \lstinline{(Bob)-[:LOVES]->(Alice)}
    \caption{A basic Cypher example}
    \label{fig:cypher-intro}
\end{figure}

Cypher syntax is elegant and expressive, thus very readable. Besides using it to represent nodes and relationships, we can utilize it to access the Neo4j's indexing capabilities and stored procedures as well. Even complex pattern-matching conditions can be expressed easily and intuitively in Cypher. Although today's modern application development frameworks — adopting increasingly capable data mapping solutions — make it less and less necessary to directly interact with databases, complex queries can still involve composing database commands manually. Therefore the expressiveness and ease of use of a database query language still remains essential.

\section{Git and GitHub}

I have been maintaining altogether 9 projects related to Diplomatiq, all being tracked by a version control system, Git. I chose Git because of its maturity\footnote{Git has been developed since 2005~\cite{git-initial-commit}.} and popularity, and also because of the fact that this is the versioning tool that I am most experienced with. For open-source software maintenance, I chose GitHub, as it is the most popular software collaboration platform~\footnote{GitHub has over 40 million users~\cite{github-user-count}.}, and offers advanced development and project management tools, security settings, and a full-featured, integrated testing infrastructure. Also, it enables to maintain repositories under a larger unit, called organization, offering sophisticated administrative and security features. GitHub is free of charge for open-source projects~\cite{github-pricing}.

\section{Microsoft Azure}

Having relevant work experience in operating a production cloud server infrastructure, I had a concrete concept on Diplomatiq's demands on the short and on the run as well. The key aspects of choosing the platform were the following:

\begin{itemize}
\item It should provide strong cloud-based services with hybrid cloud\footnote{A hybrid cloud consists of cloud-based and on-premise infrastructure elements.} capabilities for later expansion into real-world diplomacy.\footnote{According to my knowledge, governmental and diplomatic software often require on-premise solutions.}
\item It should provide strong PaaS\footnote{Platform-as-a-Service} capabilities, and also IaaS\footnote{Infrastructure-as-a-Service} solutions.
\item It should provide options on data residency to comply with diplomatic requirements.
\item It should offer a flexible pricing model, so I can start with a smaller, cheaper infrastructure, and scale it later as Diplomatiq's production workload grows.
\item It should provide mature, integrated security solutions.
\item It should provide affordable developer support.
\end{itemize}

Considering the above, I evaluated service offerings of Microsoft Azure, Google Cloud Platform, and Amazon Web Services. Google seems to lag behind on hybrid solutions, and also seems to be the worst from the financial aspect for Diplomatiq's use cases. Even though Amazon is the oldest cloud service, it seems to lack integrated data residency solutions. Microsoft seems to offer everything Diplomatiq will need in the long run, and it proved to be the best in terms of pricing, therefore I chose Microsoft Azure as Diplomatiq's cloud server infrastructure platform.
